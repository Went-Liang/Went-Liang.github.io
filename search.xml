<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>c++新特性</title>
    <url>/2023/09/24/cpp-new-feature/</url>
    <content><![CDATA[<p>一些c++新特性</p>
<span id="more"></span>

<h1 id="nodiscard"><a href="#nodiscard" class="headerlink" title="[[nodiscard]]"></a>[[nodiscard]]</h1><p>c++17引入，用于编译时检查有没有获取返回值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">fi</span><span class="params">()</span>              <span class="comment">//修饰函数返回值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> [[nodiscard]] C&#123;&#125;;            <span class="comment">//修饰类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> [[nodiscard]] E&#123;e1, e2&#125;; <span class="comment">//修饰枚举类</span></span><br><span class="line"> </span><br><span class="line"><span class="function">C <span class="title">fc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">C</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">E <span class="title">fe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> E::e1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fi</span>();    <span class="comment">//没有使用fi的返回值，告警：ignoring return value of &#x27;int fi()&#x27;, declared with attribute nodiscard</span></span><br><span class="line">    <span class="built_in">fc</span>();    <span class="comment">//没有使用fc的返回值，告警：ignoring returned value of type &#x27;C&#x27;, declared with attribute nodiscard</span></span><br><span class="line">    <span class="built_in">fe</span>();    <span class="comment">//没有使用fe的返回值，告警：ignoring returned value of type &#x27;E&#x27;, declared with attribute nodiscard</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/jiemashizhen/article/details/125567512">https://blog.csdn.net/jiemashizhen/article/details/125567512</a></p>
</blockquote>
<h1 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a>std::enable_shared_from_this</h1><p>c++11引入</p>
<p>当一个类被共享智能指针 share_ptr 管理，且在类的成员函数里需要把<strong>当前类对象</strong>作为参数传给其他函数时，这时就<strong>需要传递一个指向自身的 share_ptr</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Good</span> : std::enable_shared_from_this&lt;Good&gt; <span class="comment">// note: public inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的用法：用不安全的表达式试图获得 this 的 shared_ptr 对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Bad</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>错误的用法中getptr函数会导致问题，因为它使用this指针构造了一个新的std::shared_ptr。这将导致在析构时调用两次析构函数，从而导致未定义行为。</p>
<blockquote>
<p><a href="https://blog.csdn.net/breadheart/article/details/112451022">https://blog.csdn.net/breadheart/article/details/112451022</a></p>
</blockquote>
<h1 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a>std::variant</h1><p>功能类似union，union能够保存可能类型列表之一。但是不知道它们当前持有的值的类型。<br>std::variant可以知道类型，即使用index()知道时类型列表的第几个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::variant&lt;<span class="type">int</span>, std::string&gt; var&#123;<span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">// initialized with string alternative</span></span><br><span class="line">std::cout &lt;&lt; var.<span class="built_in">index</span>(); <span class="comment">// prints 1</span></span><br><span class="line">var = <span class="number">42</span>; <span class="comment">// now holds int alternative</span></span><br><span class="line">std::cout &lt;&lt; var.<span class="built_in">index</span>(); <span class="comment">// prints 0</span></span><br><span class="line"></span><br><span class="line">std::string s = std::<span class="built_in">get</span>&lt;std::string&gt;(var); <span class="comment">// access by type</span></span><br><span class="line"><span class="type">int</span> i = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var); <span class="comment">// access by index</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>variant 可以正确调用构造析构函数，等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">int</span> type_; </span><br><span class="line"> <span class="keyword">union</span>&#123; </span><br><span class="line"> 	<span class="keyword">struct</span> &#123;&#125; a; </span><br><span class="line"> 	<span class="keyword">struct</span> &#123;&#125; b; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><a href="https://blog.csdn.net/janeqi1987/article/details/100568096">https://blog.csdn.net/janeqi1987/article/details/100568096</a></p>
</blockquote>
<h1 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a>std::optional</h1><p>用于一个变量不一定有值的情况</p>
<p>比如，在判断bool的函数如何抛出异常，不可能让异常也是false</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getBoolValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xxx) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 计算失败时返回的false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 计算成功时返回的false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看一个optional对象是否有值，可以直接用if，或者用has_value()</p>
<p>当一个optional有值时，可以通过用指针的方式(*号和-&gt;号)来使用它，或者用.value()拿到它的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function">optional&lt;<span class="type">bool</span>&gt; <span class="title">getBoolValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xxx) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullopt</span>;  <span class="comment">// 计算失败时返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 计算成功时返回的false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">optional&lt;<span class="type">int</span>&gt; o1;  <span class="comment">//什么都不写时默认初始化为nullopt</span></span><br><span class="line">optional&lt;<span class="type">int</span>&gt; o2 = <span class="literal">nullopt</span>;  <span class="comment">//初始化为无值</span></span><br><span class="line">optional&lt;<span class="type">int</span>&gt; o3 = <span class="number">10</span>;  <span class="comment">//用一个T类型的值来初始化</span></span><br><span class="line"></span><br><span class="line">optional&lt;<span class="type">int</span>&gt; o1;</span><br><span class="line"><span class="keyword">if</span> (o1) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;o1 has value\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (o1.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;o1 has value\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/yuejisuo1948/article/details/118440275">https://blog.csdn.net/yuejisuo1948/article/details/118440275</a></p>
</blockquote>
<h1 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h1><p>c++17</p>
<p>代替void*</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::any a; <span class="comment">// a is empty</span></span><br><span class="line">std::any b = <span class="number">4.3</span>; <span class="comment">// b has value 4.3 of type double</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">42</span>; <span class="comment">// a has value 42 of type int</span></span><br><span class="line">b = std::string&#123;<span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">// b has value &quot;hi&quot; of type std::string</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(std::string)) </span><br><span class="line">&#123;</span><br><span class="line">    std::string s = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a);</span><br><span class="line">    <span class="built_in">useString</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">int</span>)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">useInt</span>(std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/janeqi1987/article/details/100568181">https://blog.csdn.net/janeqi1987/article/details/100568181</a></p>
</blockquote>
<h1 id="std-visit"><a href="#std-visit" class="headerlink" title="std::visit"></a>std::visit</h1><p>c++ 17</p>
<p>根据第二个参数的类型来执行第一个参数（函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyVisitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> d)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">var1</span><span class="params">(<span class="number">42</span>)</span>, <span class="title">var2</span><span class="params">(<span class="number">3.14</span>)</span>, <span class="title">var3</span><span class="params">(<span class="string">&quot;visit&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var1); <span class="comment">// calls operator() for matching int type</span></span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var2); <span class="comment">// calls operator() for matching double type</span></span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var3); <span class="comment">// calls operator() for matching std::string type</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/janeqi1987/article/details/100568146">https://blog.csdn.net/janeqi1987/article/details/100568146</a></p>
</blockquote>
<h1 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h1><p>c++ 17</p>
<p>像std::string一样处理字符序列，而不需要为这些字符序列分配内存。 </p>
<p>std::string_view只由一个指针和一个长度组成，标识了一段不属于string_view的字符数据，视图不能修改这段数据。 因此，复制string_view是一个浅层操作:不会复制任何字符串数据。</p>
<p><img src="https://img-blog.csdnimg.cn/1ca3d34d1f6a415292eca129e272801e.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/529073150">https://zhuanlan.zhihu.com/p/529073150</a></p>
</blockquote>
<h1 id="std-is-same-v"><a href="#std-is-same-v" class="headerlink" title="std::is_same_v"></a>std::is_same_v</h1><p>判断输入的类型是否是指定的模板类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">getValueType</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="std-decay-t"><a href="#std-decay-t" class="headerlink" title="std::decay_t"></a>std::decay_t</h1><p>decltype根据表达式推导类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">1</span>;            <span class="comment">// y -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(x + y) z = <span class="number">0</span>;        <span class="comment">// z -&gt; int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i = x;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = y;            <span class="comment">// j -&gt; const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">decltype</span><span class="params">(z)</span> *p </span>= &amp;z;    <span class="comment">// *p -&gt; const int, p -&gt; const int*</span></span><br><span class="line"><span class="keyword">decltype</span>(z) *m = &amp;z;          <span class="comment">// *m -&gt; int, m -&gt; int*</span></span><br><span class="line"><span class="keyword">decltype</span>(m)* n = &amp;m;          <span class="comment">// *n -&gt; int*, n -&gt; int**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>测试博客</title>
    <url>/2023/09/23/first-blog/</url>
    <content><![CDATA[<p>这里是摘要，点击查看全文</p>
<span id="more"></span>
<p>下午好各位。下面是头像图片：</p>
<p><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/2.jpeg" alt="img1"></p>
<p>博客搭建参考 <a href="https://mobbu.space/">https://mobbu.space/</a>，要注意的是更换主题后，记得把blog&#x2F;_config.yml里的主题改成<code>theme: next</code></p>
<p>添加数学公式需要在md头部加<code>mathjax: true</code>，公式： $f(x) &#x3D; x^2$。</p>
<p>其他md用法见<a href="https://mobbu.space/2023/08/08/20230808_markdownLanguage/">https://mobbu.space/2023/08/08/20230808_markdownLanguage&#x2F;</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
