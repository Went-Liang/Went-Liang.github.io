<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>摄影</title>
    <url>/2023/10/24/camera/</url>
    <content><![CDATA[<p>相机基本概念</p>
<span id="more"></span>
<h1 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h1><h2 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h2><h3 id="卡片机"><a href="#卡片机" class="headerlink" title="卡片机"></a>卡片机</h3><p>不可更换镜头，不能更换相机自带变焦外的其他焦段，便携</p>
<h3 id="单反"><a href="#单反" class="headerlink" title="单反"></a>单反</h3><p>机身内置有反光板和五棱镜，单反的取景是每次经过机内的五棱镜反射到取景器中观看也称光学取景。因为机身多了反光板和五棱镜，在同样规格下单反机身会比微单更大一些。</p>
<p>发展技术成熟，握持感好、续航优秀、镜头群丰富、价格相对便宜，重量高、机身庞大便携性差、连拍速度不及微单</p>
<h3 id="微单-无反相机"><a href="#微单-无反相机" class="headerlink" title="微单(无反相机)"></a>微单(无反相机)</h3><p>“无反”即是说它里边没有单反相机里面的那个反光镜以及五棱镜，它的取景器是一个电子显示屏，外界光线通过镜头最后由电子取景显示画面，也称电子取景。没有反光板每次拍摄的机械运动限制，微单在连拍速度比单反更快。</p>
<p>体积相对小巧、较易上手、连拍速度更快，镜头丰富程度不如单反，价格也比单反更贵</p>
<h2 id="相机参数"><a href="#相机参数" class="headerlink" title="相机参数"></a>相机参数</h2><h3 id="画幅"><a href="#画幅" class="headerlink" title="画幅"></a>画幅</h3><p>画幅指的是各种大小的传感器<br><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/huafu.jpg" alt="画幅"></p>
<ol>
<li><p>根据下图“焦距与视角”所示，画幅越小，视角越小。</p>
</li>
<li><p>在相同像素的情况下，画幅越大，每个像素的面积就会相对越大，接受光的能力就会越强，因此每个像素所呈现的品质就会更好，而整张照片的画质也就因此更好。</p>
</li>
</ol>
<h3 id="焦距"><a href="#焦距" class="headerlink" title="焦距"></a>焦距</h3><p>焦距的定义是：镜头的光学中心到感光元件之间的距离。</p>
<p>比如一支镜头：Z DX 18-140mm f&#x2F;3.5-6.3 VR，其中18-140mm就是表示了这支镜头的焦距。焦距有两个数字表示这是一支变焦镜头，焦距覆盖了从18mm到140mm的整个焦距段。这是一支$140 &#x2F; 18$倍的变焦镜头。</p>
<ol>
<li>焦距越小，视角越广，焦距越大，照的更远。<br><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/jiaoju.jpg" alt="焦距与视角"></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>焦距</th>
<th>视角</th>
<th>场景</th>
<th>拍摄距离</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>超广角</td>
<td>24mm以下</td>
<td>大</td>
<td>大场景，建筑，风景，新闻摄影</td>
<td>近</td>
<td>透视感强（远近变化明显），景深较深，形变大，很强的视觉冲击力</td>
</tr>
<tr>
<td>广角</td>
<td>24mm和28mm</td>
<td></td>
<td>风景</td>
<td></td>
<td></td>
</tr>
<tr>
<td>人文眼</td>
<td>35mm</td>
<td></td>
<td>人文</td>
<td></td>
<td>既能够将背景囊括进来，又可以保留足够的景深</td>
</tr>
<tr>
<td>标准镜头</td>
<td>50mm</td>
<td></td>
<td>人文、人像</td>
<td></td>
<td>最接近人眼看到的感受</td>
</tr>
<tr>
<td>人像镜头</td>
<td>85mm</td>
<td></td>
<td>人像</td>
<td></td>
<td>背景虚化好，画面裁切能力强，突出人</td>
</tr>
<tr>
<td>微距镜头</td>
<td>100mm</td>
<td></td>
<td>微距镜头</td>
<td></td>
<td></td>
</tr>
<tr>
<td>人像</td>
<td>135mm</td>
<td></td>
<td>人像</td>
<td></td>
<td></td>
</tr>
<tr>
<td>长焦镜头</td>
<td>200mm和300mm</td>
<td></td>
<td>花鸟，运动，人像</td>
<td></td>
<td>背景虚化效果超级强烈</td>
</tr>
<tr>
<td>超长焦</td>
<td>300mm以上</td>
<td>小</td>
<td>野生动物、运动题材</td>
<td>远</td>
<td>透视感弱压缩感强（远近变化不明显），景深浅，强调主题</td>
</tr>
</tbody></table>
<p>注意，上述焦距是全画幅而言的，对于其他画幅需要计算等效焦距</p>
<p><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/dengxiaojiaoju.jpg" alt="等效焦距"><br>等效焦距 &#x3D; 裁切系数 x 原焦距，佳能系统的APS-C裁切系数为1.6；尼康、索尼系统的APS-C裁切系数为1.5；而M43系统则为2。<br>同样使用50mm的镜头时，在佳能APS-C相机上等效焦距约为80mm (50mm x 1.6)，其拍出来的视角就会和全画幅相机使用80mm镜头的时候相同。</p>
<ol start="2">
<li>焦距越大景深小。焦距变大，相当于放大了照片中的某一个画面，画面被放大后，相当于原本组成一张照片的所有弥散圆都被放大了，这个时候复合人眼判断极限的弥散圆位置将会距离焦点更近，景深也将变得更浅。</li>
</ol>
<p>比如微距摄影时（大焦距），景深特别浅，很容易虚焦。</p>
<h3 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h3><p>ISO(感光度) 指的是数码相机感光元件对光线的敏感程度，以ISO 50, ISO 100 , ISO 200, ISO 400, ISO 800 , ISO 1600 , ISO 3200 , ISO 6400来表示相机的感光度。数字高一倍代表感光度提高一倍。</p>
<ol>
<li>影响曝光：ISO 100的照片会比ISO 200的照片暗一倍，如果要将它调整成和ISO 200一样的曝光度，就需要将光圈增大一级、或是将快门速度延长一倍。</li>
<li>影响照片画质：感光度越高，信噪比越低，画质就越差。即感光度越高，照片的画质就会越差。<br><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/iso.png" alt="ISO与画质"></li>
</ol>
<h3 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h3><p>控制光线照射在感光元件上的时间, 单位为秒，比如1&#x2F; 30, 1&#x2F; 60 , 1&#x2F; 125, 1&#x2F; 400, 1&#x2F; 4000这种快门速度，而大于1秒的话则会以1, 2, 5, 30的方式表达。</p>
<ol>
<li>影响曝光：1&#x2F; 30秒的照片会比1&#x2F; 60秒的亮一倍，如果要将它调整成和1&#x2F; 60 秒一样的曝光度，就需要将光圈缩小一级、或是将感光度减少一半。</li>
<li>影响运动物体形态：高速快门能将运动拍清晰，也就是将运动物体定格下来；慢速快门则能将运动物体拍出运动轨迹，比如：光轨、丝状瀑布等等。</li>
</ol>
<h3 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h3><p>光圈是镜头内一个控制孔径大小的组件，由数个光圈叶片所组成，主要用来控制进光量。<br>光圈F值 &#x3D; 镜头的焦距&#x2F;镜头口径的直径。以f&#x2F;值来表示光圈的大小（数值越小光圈越大），比如f&#x2F; 1 , f&#x2F; 1.4 , f&#x2F; 2 , f&#x2F; 2.8 , f&#x2F; 4 , f&#x2F; 5.6 , f&#x2F; 8 , f&#x2F; 11 , f&#x2F; 16 , f&#x2F; 22，其中f&#x2F; 1表示大光圈。同焦距镜头，那么光圈数值可以理解为光圈直径（半径）的倒数。</p>
<ol>
<li><p>光圈越大，进光量越多<br><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/jingguangliang.png" alt="光圈与进光量"></p>
</li>
<li><p>光圈越大，景深越浅，背景越模糊；光圈越小，景深越深，背景越清晰</p>
</li>
</ol>
<p>通常来说，物体反射的光经过透镜折射后的焦点刚好在感光元件上时是最清晰的，但焦点在感光元件前后一定范围内时对人眼来说也是清晰的，将清晰时的感光元件上的面称之为容许弥散圆。<br><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/misanyaun.png" alt="容许弥散圆"></p>
<p>由于光圈的存在，折射光线形成的光锥变窄，容许弥散圆对应的前后焦深也变大，景深也变大，如下图所示：<br><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/jingshen1.png" alt="光圈与景深成反比"></p>
<h3 id="白平衡"><a href="#白平衡" class="headerlink" title="白平衡"></a>白平衡</h3><p>首先了解色温，色温是指光线的颜色，其表示方法是用温度(K) 来呈现(Kelvin,开尔文)。色温较低(4000K以下) 颜色偏暖；色温较高(6000K以上) 颜色较冷；而中间色温(4000-6000K) 则是中性偏白光。</p>
<blockquote>
<p>将一个黑体金属从绝对零度(0K) 的时候开始加热，黑体会随着温度上升开始发出不同颜色的光(黑体辐射光)：当温度达到约2000 K 时, 此时黑体呈现红色；当温度达到约5500 K 时，此时黑体发出类似太阳光的白光； 当温度达到约9000 K 时，此时黑体则呈现蓝色。把红色、橘色、黄色、白色、蓝色等光源，将之和黑体辐射的颜色作为对比，便把色温这个词给定义出来了。举例来说，火柴燃烧时放出来的红橘光线，和黑体在1700K发出的颜色一致，因此定义火柴光的色温为1700K；再举例，在阴天下的光线会比较偏蓝，大概和黑体6500K发出的颜色一致，因此定义阴天下的色温为6500K。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/sewen.png" alt="色温"></p>
<p>白平衡是将在不同环境色温中的白色物体都还原成真的白色。如下图所示，通过调整相机白平衡，来还原原本的白色：</p>
<blockquote>
<p><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/baipingheng.jpg" alt="白平衡"></p>
</blockquote>
<p>调整策略包括：白色优先，氛围优先。</p>
<p>自动白平衡功能：即AWB(Auto White Balance)，只要选择这个模式，相机就会自动侦测环境光源、自动完成白平衡调整；<br>自定义白平衡功能：在当前环境下提供白色的样板，给相机看在这个环境色温里变成的颜色，相机自动校正；<br>场景模式：提供场景<br>K模式：手动定义色温</p>
<h3 id="对焦模式"><a href="#对焦模式" class="headerlink" title="对焦模式"></a>对焦模式</h3><h3 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h3><p>RAW是未经过任何处理的影像资料，也就是说RAW保留了所有感光元件上搜集的原始资讯，包含曝光、白平衡、色调、颜色、风格等等。</p>
<p>RAW包含更多的画面细节和更佳的画质表现以及更高的动态范围，色彩更是高达12-14 位元。因此在后期制作上不仅可以进行较大范围的曝光值调整、白平衡校正、颜色间也比较不会有断层的状况产生。但文档过大、影响连拍速度。</p>
<h3 id="动态范围"><a href="#动态范围" class="headerlink" title="动态范围"></a>动态范围</h3><p>动态范围是相机可以在多大范围内捕捉图像的影调细节，通常指由最低值到最高溢出值之间的范围。描述的是相机在单帧内可以记录的最亮和最暗影调之间的比率。</p>
<p>当你拍摄的图像在光线上有巨大的差异时，更大的动态范围就能获得更大的影调空间。</p>
<blockquote>
<p>例如一个有明亮窗户和昏暗内部的地点。来自窗户的光线比墙壁内部的光线要亮得多，如果动态范围不够大，这时要么窗户的光线太亮，曝光过度（看起来是白色的），要么墙壁太暗，曝光不足（看起来是黑色的），这会导致图像失去细节。<br><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/dongtai.png" alt="高动态范围"></p>
</blockquote>
<h2 id="影像概念"><a href="#影像概念" class="headerlink" title="影像概念"></a>影像概念</h2><h3 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h3><p>“光圈、快门、感光度”被称为“曝光三要素”<br><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/gkg.webp" alt="曝光三要素"></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>光圈</th>
<th>快门</th>
<th>ISO</th>
</tr>
</thead>
<tbody><tr>
<td>夜景</td>
<td>小光圈(大景深)</td>
<td>慢速(提高曝光)</td>
<td>低感光度(提高画质)</td>
</tr>
<tr>
<td>运动定格</td>
<td>大光圈(虚化背景)</td>
<td>高速(定格)</td>
<td>高感光度(提高曝光)</td>
</tr>
<tr>
<td>光轨</td>
<td>中小光圈(大景深)</td>
<td>慢速</td>
<td>低感光度(提高画质)</td>
</tr>
</tbody></table>
<h3 id="视角"><a href="#视角" class="headerlink" title="视角"></a>视角</h3><ol>
<li>画幅越小，视角越小</li>
<li>焦距越小，视角越大</li>
</ol>
<h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><p>对焦点的前后范围中，影像清晰的深度有多少，称之为景深，即相片对应的现实中清晰的范围，影响景深的3大重要因素：光圈、焦距、拍摄者和被摄物之间的距离。</p>
<ol>
<li>光圈越大，景深越小，虚化越明显</li>
<li>拍摄者和被摄物之间的距离越大，景深越大（与光圈同理，受容许弥散圆对应的前后焦深影响）</li>
</ol>
<p>不同画幅的相机就算使用相同镜头和焦距，也会有完全不同的视角。APS-C相机使用50mm来拍摄时，全画幅相机则需要使用80mm的焦距，才能在同样站位上获得相似的构图，也就是因为使用的焦距较长，拍摄出来的画面自然就有较浅的景深。</p>
<blockquote>
<p>摄影新手入门：1分钟搞懂焦距是什么？焦距与视角的关系！ - 走路不带风的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/619352287">https://zhuanlan.zhihu.com/p/619352287</a><br><a href="https://www.zhihu.com/column/c_1623821616076537857">https://www.zhihu.com/column/c_1623821616076537857</a><br><a href="https://www.bilibili.com/video/BV1t24y1k7Ye/?spm_id_from=333.337.search-card.all.click&vd_source=668f39404189897ee2f8d0c7596f9f4e">https://www.bilibili.com/video/BV1t24y1k7Ye/?spm_id_from=333.337.search-card.all.click&amp;vd_source=668f39404189897ee2f8d0c7596f9f4e</a><br>光圈、快门、感光度，弄懂摄影基本算入门了 - 王路飞的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/134166476">https://zhuanlan.zhihu.com/p/134166476</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数码</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>数码</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>c++新特性</title>
    <url>/2023/09/24/cpp-new-feature/</url>
    <content><![CDATA[<p>一些c++新特性</p>
<span id="more"></span>

<h1 id="nodiscard"><a href="#nodiscard" class="headerlink" title="[[nodiscard]]"></a>[[nodiscard]]</h1><p>c++17引入，用于编译时检查有没有获取返回值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">fi</span><span class="params">()</span>              <span class="comment">//修饰函数返回值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> [[nodiscard]] C&#123;&#125;;            <span class="comment">//修饰类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> [[nodiscard]] E&#123;e1, e2&#125;; <span class="comment">//修饰枚举类</span></span><br><span class="line"> </span><br><span class="line"><span class="function">C <span class="title">fc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">C</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">E <span class="title">fe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> E::e1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fi</span>();    <span class="comment">//没有使用fi的返回值，告警：ignoring return value of &#x27;int fi()&#x27;, declared with attribute nodiscard</span></span><br><span class="line">    <span class="built_in">fc</span>();    <span class="comment">//没有使用fc的返回值，告警：ignoring returned value of type &#x27;C&#x27;, declared with attribute nodiscard</span></span><br><span class="line">    <span class="built_in">fe</span>();    <span class="comment">//没有使用fe的返回值，告警：ignoring returned value of type &#x27;E&#x27;, declared with attribute nodiscard</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/jiemashizhen/article/details/125567512">https://blog.csdn.net/jiemashizhen/article/details/125567512</a></p>
</blockquote>
<h1 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a>std::enable_shared_from_this</h1><p>c++11引入</p>
<p>当一个类被共享智能指针 share_ptr 管理，且在类的成员函数里需要把<strong>当前类对象</strong>作为参数传给其他函数时，这时就<strong>需要传递一个指向自身的 share_ptr</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Good</span> : std::enable_shared_from_this&lt;Good&gt; <span class="comment">// note: public inheritance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Good&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的用法：用不安全的表达式试图获得 this 的 shared_ptr 对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Bad&gt; <span class="title">getptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;Bad&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Bad</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Bad::~Bad() called\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>错误的用法中getptr函数会导致问题，因为它使用this指针构造了一个新的std::shared_ptr。这将导致在析构时调用两次析构函数，从而导致未定义行为。</p>
<blockquote>
<p><a href="https://blog.csdn.net/breadheart/article/details/112451022">https://blog.csdn.net/breadheart/article/details/112451022</a></p>
</blockquote>
<h1 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a>std::variant</h1><p>功能类似union，union能够保存可能类型列表之一。但是不知道它们当前持有的值的类型。<br>std::variant可以知道类型，即使用index()知道时类型列表的第几个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::variant&lt;<span class="type">int</span>, std::string&gt; var&#123;<span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">// initialized with string alternative</span></span><br><span class="line">std::cout &lt;&lt; var.<span class="built_in">index</span>(); <span class="comment">// prints 1</span></span><br><span class="line">var = <span class="number">42</span>; <span class="comment">// now holds int alternative</span></span><br><span class="line">std::cout &lt;&lt; var.<span class="built_in">index</span>(); <span class="comment">// prints 0</span></span><br><span class="line"></span><br><span class="line">std::string s = std::<span class="built_in">get</span>&lt;std::string&gt;(var); <span class="comment">// access by type</span></span><br><span class="line"><span class="type">int</span> i = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var); <span class="comment">// access by index</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>variant 可以正确调用构造析构函数，等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">int</span> type_; </span><br><span class="line"> <span class="keyword">union</span>&#123; </span><br><span class="line"> 	<span class="keyword">struct</span> &#123;&#125; a; </span><br><span class="line"> 	<span class="keyword">struct</span> &#123;&#125; b; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><a href="https://blog.csdn.net/janeqi1987/article/details/100568096">https://blog.csdn.net/janeqi1987/article/details/100568096</a></p>
</blockquote>
<h1 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a>std::optional</h1><p>用于一个变量不一定有值的情况</p>
<p>比如，在判断bool的函数如何抛出异常，不可能让异常也是false</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getBoolValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xxx) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 计算失败时返回的false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 计算成功时返回的false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看一个optional对象是否有值，可以直接用if，或者用has_value()</p>
<p>当一个optional有值时，可以通过用指针的方式(*号和-&gt;号)来使用它，或者用.value()拿到它的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function">optional&lt;<span class="type">bool</span>&gt; <span class="title">getBoolValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xxx) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullopt</span>;  <span class="comment">// 计算失败时返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 计算成功时返回的false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">optional&lt;<span class="type">int</span>&gt; o1;  <span class="comment">//什么都不写时默认初始化为nullopt</span></span><br><span class="line">optional&lt;<span class="type">int</span>&gt; o2 = <span class="literal">nullopt</span>;  <span class="comment">//初始化为无值</span></span><br><span class="line">optional&lt;<span class="type">int</span>&gt; o3 = <span class="number">10</span>;  <span class="comment">//用一个T类型的值来初始化</span></span><br><span class="line"></span><br><span class="line">optional&lt;<span class="type">int</span>&gt; o1;</span><br><span class="line"><span class="keyword">if</span> (o1) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;o1 has value\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (o1.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;o1 has value\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/yuejisuo1948/article/details/118440275">https://blog.csdn.net/yuejisuo1948/article/details/118440275</a></p>
</blockquote>
<h1 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h1><p>c++17</p>
<p>代替void*</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::any a; <span class="comment">// a is empty</span></span><br><span class="line">std::any b = <span class="number">4.3</span>; <span class="comment">// b has value 4.3 of type double</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">42</span>; <span class="comment">// a has value 42 of type int</span></span><br><span class="line">b = std::string&#123;<span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">// b has value &quot;hi&quot; of type std::string</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (a.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(std::string)) </span><br><span class="line">&#123;</span><br><span class="line">    std::string s = std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a);</span><br><span class="line">    <span class="built_in">useString</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="built_in">type</span>() == <span class="built_in">typeid</span>(<span class="type">int</span>)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">useInt</span>(std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/janeqi1987/article/details/100568181">https://blog.csdn.net/janeqi1987/article/details/100568181</a></p>
</blockquote>
<h1 id="std-visit"><a href="#std-visit" class="headerlink" title="std::visit"></a>std::visit</h1><p>c++ 17</p>
<p>根据第二个参数的类型来执行第一个参数（函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyVisitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> d)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">var1</span><span class="params">(<span class="number">42</span>)</span>, <span class="title">var2</span><span class="params">(<span class="number">3.14</span>)</span>, <span class="title">var3</span><span class="params">(<span class="string">&quot;visit&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var1); <span class="comment">// calls operator() for matching int type</span></span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var2); <span class="comment">// calls operator() for matching double type</span></span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">visit</span>(<span class="built_in">MyVisitor</span>(), var3); <span class="comment">// calls operator() for matching std::string type</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/janeqi1987/article/details/100568146">https://blog.csdn.net/janeqi1987/article/details/100568146</a></p>
</blockquote>
<h1 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h1><p>c++ 17</p>
<p>像std::string一样处理字符序列，而不需要为这些字符序列分配内存。 </p>
<p>std::string_view只由一个指针和一个长度组成，标识了一段不属于string_view的字符数据，视图不能修改这段数据。 因此，复制string_view是一个浅层操作:不会复制任何字符串数据。</p>
<p><img src="https://img-blog.csdnimg.cn/1ca3d34d1f6a415292eca129e272801e.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/529073150">https://zhuanlan.zhihu.com/p/529073150</a></p>
</blockquote>
<h1 id="std-is-same-v"><a href="#std-is-same-v" class="headerlink" title="std::is_same_v"></a>std::is_same_v</h1><p>判断输入的类型是否是指定的模板类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">getValueType</span><span class="params">(T v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same_v&lt;T, <span class="type">int</span>&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="std-decay-t"><a href="#std-decay-t" class="headerlink" title="std::decay_t"></a>std::decay_t</h1><p>decltype根据表达式推导类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">1</span>;            <span class="comment">// y -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(x + y) z = <span class="number">0</span>;        <span class="comment">// z -&gt; int</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i = x;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = y;            <span class="comment">// j -&gt; const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">decltype</span><span class="params">(z)</span> *p </span>= &amp;z;    <span class="comment">// *p -&gt; const int, p -&gt; const int*</span></span><br><span class="line"><span class="keyword">decltype</span>(z) *m = &amp;z;          <span class="comment">// *m -&gt; int, m -&gt; int*</span></span><br><span class="line"><span class="keyword">decltype</span>(m)* n = &amp;m;          <span class="comment">// *n -&gt; int*, n -&gt; int**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>测试博客</title>
    <url>/2023/09/23/first-blog/</url>
    <content><![CDATA[<p>这里是摘要，点击查看全文</p>
<span id="more"></span>
<p>下午好各位。下面是头像图片：</p>
<p><img src="https://raw.githubusercontent.com/Went-Liang/ImageTG/main/PicGo/img/2.jpeg" alt="img1"></p>
<p>博客搭建参考 <a href="https://mobbu.space/">https://mobbu.space/</a>，要注意的是更换主题后，记得把blog&#x2F;_config.yml里的主题改成<code>theme: next</code></p>
<p>添加数学公式需要在md头部加<code>mathjax: true</code>，公式： $f(x) &#x3D; x^2$。</p>
<p>其他md用法见<a href="https://mobbu.space/2023/08/08/20230808_markdownLanguage/">https://mobbu.space/2023/08/08/20230808_markdownLanguage&#x2F;</a></p>
<p>每次修改后都使用这三条命令将本地修改部分同步到github上：</p>
<pre><code>hexo clean   # 清除缓存文件 db.json 和已生成的静态文件 public
hexo g       # 生成网站静态文件到默认设置的 public 文件夹
hexo s       # 在本地进行预览网页效果再决
hexo d       # 生成网站静态文件，并部署到指定仓库 
</code></pre>
]]></content>
      <categories>
        <category>博客使用指南</category>
      </categories>
  </entry>
</search>
